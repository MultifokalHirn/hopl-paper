\documentclass[oribibl]{llncs}
\usepackage[utf8]{inputenc}
\usepackage{llncsdoc}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
%
\author{Lennard Wolf \\
        lennard.wolf@student.hpi.de}
\institute{ Hasso Plattner Institute \\
            Prof.-Dr.-Helmert-Straße 2-3 \\
            14482 Potsdam \\
            Germany}
\title{Describing Dynamic Organizational Structures \\
 through the Common Lisp Object System}
\date{\today}
%
\begin{document}
\markboth{Describing Dynamic Organizational Structures \\
 through the Common Lisp Object System}{Describing Dynamic Organizational Structures \\
 through the Common Lisp Object System}
\thispagestyle{empty}
\vfill

%
\maketitle
%
\begin{abstract}
Describing Dynamic Organizational Structures through the Common Lisp Object System Describing Dynamic Organizational Structures through the Common Lisp Object System Describing Dynamic Organizational Structures through the Common Lisp Object System Describing Dynamic Organizational Structures through the Common Lisp Object System Describing Dynamic Organizational Structures through the Common Lisp Object System Describing Dynamic Organizational Structures through the Common Lisp Object System Describing Dynamic Organizational Structures through the Common Lisp Object System
\end{abstract}
%





\section{Introduction}

\textbf{My notations}

\begin{itemize}
\item "term" : wording unsure
\end{itemize}


% Topic / Domain


% Problem


% Contribution


% Outline
The following is a summary of each section. In section...

\section{Problem}
\label{sec:problem}

\begin{itemize}
\item To gain an overview of the "workings" within organizational structures it is often useful to have the participants and their "occupations"/"roles" written down somewhere. 
\item say a system needs all participants to be objects
\item their occupations would define their possible interactions, rights etc
\item in many structures will not only the people come and leave, but they might also change their occupations
\item example case university: professors can also be "CEOs", students can also be tutors etc
\item how would it be possible to "abbilden" this within a software system, so that it is easily maintainable - meaning that individuals can change their jobs etc - and that it is easily extendable - meaning that new occupations can easily added and combined with already existing ones
\end{itemize}


\section{Context}
\label{sec:context}
A "solid" solution to the problem introduced in Section \ref{sec:problem} would be to use the \emph{Common Lisp Object System} (CLOS), an extension to Common Lisp\footnote{\url{https://common-lisp.net}, accessed: XXXXXX} providing "full" object-orientation. \cite{CLOSOverview} However to understand its utilization in such a problem domain as well as the reasoning behind that, some background information will be needed first.

In this Section we will hence start out by introducing the general ideas behind object-orientated programming languages, as well as the language Lisp, which is followed by a description of the three main concepts that make CLOS unique. An overview of the history of CLOS will be provided thereafter, so as to better understand its origins and historical context.

\subsection{Object-Orientated Languages}
\label{sec:oo}

A definition of \emph{object-orientated} programming languages requires a preceding explanation of the terms \emph{object}, \emph{class}, and \emph{inheritance}. \emph{Objects} have a set of \emph{attributes} that define its \emph{state}, as well as a number of \emph{messages} that it can receive to evoke certain behavior. By sending such messages, objects can interact with one another. \emph{Classes} are templates for objects, so that objects of the same class can have uniform interfaces and behavior. \emph{Inheritance} opens up the possibility to create class hierarchies, so that classes can be specializations of others and \emph{inherit} certain behavior while adding something unique. 

An \emph{object-orientated} programming language is one that has these three concepts "integrated". They give programmers the ability to model human language based conceptualizations of the real world, since these are also just seperations of phenomena into groups with common traits.

\subsection{Lisp}
\label{sec:lisp}

Stemming from the term \textbf{Lis}t \textbf{P}rocessor, Lisp is a programming language in which \emph{everything is a list}. This means that there is \emph{no discernment between data and code}. Hence an expression such as \texttt{(plus 3 4)} is without context nothing more than a "meaningless" listing of the "meaningless" expressions \texttt{plus}, \texttt{3}, and \texttt{4}. An expression like that only gets its meaning from an \emph{evaluation} by the interpreter which considers it in a certain context. In such a context the expression \texttt{plus} could be a function to add the arguments it is given, but that is entirely arbitrary. 

Common Lisp is a standardized version of Lisp which provides certain data types and operations. But this type system can be extended through the use of \emph{macros}, which let developers give meaning to expressions. This feature of Lisp makes it "easy" to create \emph{Domain Specific Languages}\footnote{XXXX Link to or explain DSL}. \cite{XXX} They also form the basis of CLOS which in its entirety consists of 8 macros and 33 functions.


\textbf{explain Macros in detail?}

%reasoning why before concepts: the loops and s.o. are introduced which are needed later on

\subsection{History of CLOS}
\label{sec:history}

\begin{itemize}
\item object orientation became desirable (cite), thus many attempts at oo built on top of Common (?) Lisp were made
\item these many implementations caused “Tower of Babel” situation (Flavors, CommonLoops, others?)
\item 1986: Workgroup of different researchers from Xerox PARC (CommonLoops) and Symbolic Inc. (New Flavors) worked on it together to standardize just like CL
\item meta-object protocol - explanation?
\item CLOS is portable to different LISP implementations
\end{itemize}


\subsection{Main Concepts}
\label{sec:concepts}

CLOS, being an early (?) implementation of object-orientation, comprises concepts that are rather uncommon in modern object-orientated languages. This is, in the cases of \emph{generic functions} and \emph{method combination}, due to their specificity to the Lisp environment and, in the case of \emph{multiple inheritance}, because it can cause many problems if employed in contexts that are inappropriate, which they more often than not are. \cite{XXX}

\textbf{Explain Syntax Basics first? Or do this through Implementation later?}

\subsubsection{Multiple Inheritance}
\label{sec:mulinh}
blablablablablablablablablablablabla

\subsubsection{Generic Functions}
\label{sec:genfun}
blablablablablablablablablablablabla

\subsubsection{Method Combination}
\label{sec:metcom}
blablablablablablablablablablablabla

\textbf{Put visualisations together!}


%\begin{figure}[ht]
%    \centering
%    \includegraphics[width=0.6\textwidth]{images/example.jpg}
%    \caption{test}
%    \label{fig:computing_primes}
%\end{figure}



\section{Approach}
\label{sec:approach}


\begin{itemize}
\item 3 concepts will be used
\item maybe give function that lets user add classes
\end{itemize}


\section{Implementation}
\label{sec:implementation}

\begin{itemize}
\item give code details for concepts from Approach
\end{itemize}

\section{Evaluation}
\label{sec:evaluation}

\begin{itemize}
\item DSL type declaration is easily maintainable
\item using langs like Java (?) might be problematic, give example
\end{itemize}


\section{Conclusion}
\label{sec:conclusion}
Write me pl0x

\newpage
\nocite{*}
\bibliographystyle{splncs}
\bibliography{hopl-paper}

\end{document}